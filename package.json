{
  "_args": [
    [
      {
        "raw": "baobab@https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
        "scope": null,
        "escapedName": "baobab",
        "name": "baobab",
        "rawSpec": "https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
        "spec": "https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
        "type": "remote"
      },
      "/Users/macmini/Projects/ptf-vagrant/fbu"
    ]
  ],
  "_from": "baobab@>=1.1.0 <2.0.0",
  "_id": "baobab@1.1.2",
  "_inCache": true,
  "_location": "/baobab",
  "_phantomChildren": {},
  "_requested": {
    "raw": "baobab@https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
    "scope": null,
    "escapedName": "baobab",
    "name": "baobab",
    "rawSpec": "https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
    "spec": "https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
  "_shasum": "ec718a5fdf1d90016c2dbfe5ed227cd0134729a1",
  "_shrinkwrap": null,
  "_spec": "baobab@https://registry.npmjs.org/baobab/-/baobab-1.1.2.tgz",
  "_where": "/Users/macmini/Projects/ptf-vagrant/fbu",
  "author": {
    "name": "Guillaume Plique",
    "url": "http://github.com/Yomguithereal"
  },
  "bugs": {
    "url": "https://github.com/Yomguithereal/baobab/issues"
  },
  "dependencies": {
    "emmett": "^3.0.1"
  },
  "description": "JavaScript persistent data tree with cursors.",
  "devDependencies": {
    "async": "^1.2.1",
    "benchmark": "^1.0.0",
    "browserify": "^10.2.4",
    "gulp": "^3.8.10",
    "gulp-header": "^1.2.2",
    "gulp-jshint": "^1.9.0",
    "gulp-mocha": "^2.0.0",
    "gulp-rename": "^1.2.2",
    "gulp-replace": "^0.5.3",
    "gulp-uglify": "^1.0.2",
    "lodash": "^3.6.0",
    "mocha": "^2.0.1",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0"
  },
  "homepage": "https://github.com/Yomguithereal/baobab",
  "keywords": [
    "cursors",
    "atom",
    "tree",
    "react"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "baobab",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/Yomguithereal/baobab.svg)](https://travis-ci.org/Yomguithereal/baobab)\n\n# Baobab\n\n**Baobab** is a JavaScript [persistent](http://en.wikipedia.org/wiki/Persistent_data_structure) and optionally [immutable](http://en.wikipedia.org/wiki/Immutable_object) data tree supporting cursors and enabling developers to easily navigate and monitor nested data.\n\nIt is mainly inspired by functional [zippers](http://clojuredocs.org/clojure.zip/zipper) such as Clojure's ones and by [Om](https://github.com/swannodette/om)'s cursors.\n\nIt aims at providing a centralized model holding an application's state and can be paired with **React** easily through mixins, higher order components, wrapper components or decorators (available [there](https://github.com/Yomguithereal/baobab-react)).\n\nFor a concise introduction about the library and how it can be used in a React/Flux application, you can head toward **@christianalfoni**'s [article](http://christianalfoni.github.io/javascript/2015/02/06/plant-a-baobab-tree-in-your-flux-application.html) on the subject.\n\n**Fun fact**: A [Baobab](http://en.wikipedia.org/wiki/Adansonia_digitata), or *Adansonia digitata*, is a very big and magnificient African tree.\n\n## Summary\n\n* [Example](#example)\n* [Installation](#installation)\n* [Usage](#usage)\n  * [Basics](#basics)\n    * [Instantiation](#instantiation)\n    * [Cursors](#cursors)\n    * [Updates](#updates)\n    * [Events](#events)\n  * [Advanced](#advanced)\n    * [Polymorphisms](#polymorphisms)\n    * [Traversal](#traversal)\n    * [Options](#options)\n    * [Facets](#facets)\n    * [History](#history)\n    * [Update specifications](#update-specifications)\n    * [Chaining mutations](#chaining-mutations)\n    * [Common pitfalls](#common-pitfalls)\n* [Philosophy](#philosophy)\n* [Migration](#migration)\n* [Contribution](#contribution)\n* [License](#license)\n\n## Example\n\n```js\nvar Baobab = require('baobab');\n\nvar tree = new Baobab({\n  palette: {\n    colors: ['yellow', 'purple'],\n    name: 'Glorious colors'\n  }\n});\n\nvar colorsCursor = tree.select('palette', 'colors');\n\ncolorsCursor.on('update', function() {\n  console.log('Selected colors have updated:', colorsCursor.get());\n});\n\ncolorsCursor.push('orange');\n```\n\n## Installation\n\nIf you want to use **Baobab** with node.js/io.js or browserify/webpack etc., you can use npm.\n\n```sh\nnpm install baobab\n\n# Or if you need the latest dev version\nnpm install git+https://github.com/Yomguithereal/baobab.git\n```\n\nIf you want to use it in the browser, just include the minified script located [here](https://raw.githubusercontent.com/Yomguithereal/baobab/master/build/baobab.min.js).\n\n```html\n<script src=\"baobab.min.js\"></script>\n```\n\nOr install with bower:\n\n```js\nbower install baobab\n```\n\nThe library (as a standalone) currently weights ~20ko minified and ~6ko gzipped.\n\n## Usage\n\n### Basics\n\n#### Instantiation\n\nCreating a tree is as simple as instantiating *Baobab* with an initial data set.\n\n```js\nvar Baobab = require('baobab');\n\nvar tree = new Baobab({hello: 'world'});\n\n// Retrieving data from your tree\ntree.get();\n>>> {hello: 'world'}\n```\n\n#### Cursors\n\nThen you can create cursors to easily access nested data in your tree and be able to listen to changes concerning the part of the tree you selected.\n\n```js\n// Considering the following tree\nvar tree = new Baobab({\n  palette: {\n    name: 'fancy',\n    colors: ['blue', 'yellow', 'green']\n  }\n});\n\n// Creating a cursor on the palette\nvar paletteCursor = tree.select('palette');\npaletteCursor.get();\n>>> {name: 'fancy', colors: ['blue', 'yellow', 'green']}\n\n// Creating a cursor on the palette's colors\nvar colorsCursor = tree.select('palette', 'colors');\ncolorsCursor.get();\n>>> ['blue', 'yellow', 'green']\n\n// Creating a cursor on the palette's third color\nvar thirdColorCursor = tree.select('palette', 'colors', 2);\nthirdColorCursor.get();\n>>> 'green'\n\n// Note you can also perform subselections if needed\nvar colorCursor = paletteCursor.select('colors');\n```\n\n#### Updates\n\nA *baobab* tree can obviously be updated. However, one has to understand that the library won't do so, at least by default, synchronously.\n\nRather, the tree will stack and merge every update order you give it and will only commit them later on (note that you remain free to force a synchronous update of the tree through `tree.commit` or by tweaking the tree's [options](#options)).\n\nThis enables the tree to perform efficient mutations and to be able to notify any relevant cursors that the data they are watching over has changed.\n\n**Important**: Note that the tree will shift the references of the objects it stores in order to enable *immutabley* comparisons between one version of the state and another (this is especially useful when using things as such as React's [PureRenderMixin](https://facebook.github.io/react/docs/pure-render-mixin.html)).\n\n*Example*\n\n```js\nvar tree = new Baobab({hello: 'world'});\n\nvar initialState = tree.get();\ntree.set('hello', 'monde');\n\n// After asynchronous update...\nassert(initialState !== tree.get());\n```\n\n##### Tree level\n\n*Setting a key*\n\n```js\ntree.set('hello', 'world');\n```\n\n*Unsetting a key*\n\n```js\ntree.unset('hello');\n```\n\n##### Cursor level\n\n*Replacing data at cursor*\n\n```js\ncursor.set({hello: 'world'});\n```\n\n*Setting a key*\n\n```js\ncursor.set('hello', 'world');\n\n// Nested path\ncursor.set(['one', 'two'], 'world');\n```\n\n*Removing data at cursor*\n\n```js\ncursor.unset();\n```\n\n*Unsetting a key*\n\n```js\ncursor.unset('hello');\n\n// Nested path\ncursor.unset(['one', 'two']);\n```\n\n*Pushing values*\n\nObviously this will fail if the value at cursor is not an array.\n\n```js\ncursor.push('purple');\n\n// Pushing several values\ncursor.push(['purple', 'orange']);\n\n// At key\ncursor.push('list', 'orange')\n\n// Nested path\ncursor.push(['one', 'two'], 'orange');\n```\n\n*Unshifting values*\n\nObviously this will fail if the value at cursor is not an array.\n\n```js\ncursor.unshift('purple');\n\n// Unshifting several values\ncursor.unshift(['purple', 'orange']);\n\n// At key\ncursor.unshift('list', 'orange')\n\n// Nested path\ncursor.unshift(['one', 'two'], 'orange');\n```\n\n*Splicing an array*\n\nObviously this will fail if the value at cursor is not an array.\n\n```js\ncursor.splice([1, 1]);\n\n// Applying splice n times with different arguments\ncursor.splice([[1, 2], [3, 2, 'hello']]);\n\n// At key\ncursor.splice('list', [1, 1])\n\n// Nested path\ncursor.splice(['one', 'two'], [1, 1]);\n```\n\n*Applying a function*\n\n```js\nvar inc = function(currentData) {\n  return currentData + 1;\n};\n\ncursor.apply(inc);\n\n// At key\ncursor.apply('number', inc)\n\n// Nested path\ncursor.apply(['one', 'two'], inc);\n```\n\n*Chaining functions through composition*\n\nFor more details about this particular point, check [this](#chaining-mutations).\n\n```js\nvar inc = function(currentData) {\n  return currentData + 1;\n};\n\ncursor.chain(inc);\n\n// At key\ncursor.chain('number', inc)\n\n// Nested path\ncursor.chain(['one', 'two'], inc);\n```\n\n*Shallowly merging objects*\n\nObviously this will fail if the value at cursor is not an object.\n\n```js\ncursor.merge({hello: 'world'});\n\n// At key\ncursor.merge('object', {hello: 'world'})\n\n// Nested path\ncursor.merge(['one', 'two'], {hello: 'world'});\n```\n\n#### Events\n\nWhenever an update is committed, events are fired to notify relevant parts of the tree that data was changed so that bound elements, React components, for instance, can update.\n\nNote however that **only** relevant cursors will be notified of a change.\n\nEvents can be bound to either the tree or cursors using the `on` method.\n\n*Example*\n\n```js\n// Considering the following tree\nvar tree = new Baobab({\n  users: {\n    john: {\n      firstname: 'John',\n      lastname: 'Silver'\n    },\n    jack: {\n      firstname: 'Jack',\n      lastname: 'Gold'\n    }\n  }\n});\n\n// And the following cursors\nvar usersCursor = tree.select('users'),\n    johnCursor = usersCursor.select('john'),\n    jackCursor = usersCursor.select('jack');\n\n// If we update both users\njohnCursor.set('firstname', 'John the third');\njackCursor.set('firstname', 'Jack the second');\n// Every cursor above will be notified of the update\n\n// But if we update only john\njohnCursor.set('firstname', 'John the third');\n// Only the users and john cursors will be notified\n```\n\n##### Tree level\n\n*update*\n\nWill fire if the tree is updated.\n\n```js\ntree.on('update', function(e) {\n  console.log('Update log', e.data.log);\n  console.log('Previous data', e.data.previousData);\n});\n```\n\n*invalid*\n\nWill fire if the `validate` function (see [options](#options)) returned an error for the current update.\n\n```js\ntree.on('invalid', function(e) {\n  console.log('Error:', e.data.error);\n});\n```\n\n*get*\n\nWill fire whenever data is accessed in the tree.\n\n```js\ntree.on('get', function(e) {\n  console.log('Path:', e.data.path);\n  console.log('Target data:', e.data.data);\n});\n```\n\n*select*\n\nWill fire whenever a path is selected in the tree.\n\n```js\ntree.on('select', function(e) {\n  console.log('Path:', e.data.path);\n  console.log('Resultant cursor:', e.data.cursor);\n});\n```\n\n##### Cursor level\n\n*update*\n\nWill fire if data watched over by the cursor has updated.\n\n```js\ncursor.on('update', fn);\n```\n\n*irrelevant*\n\nWill fire if the cursor has become irrelevant and does not watch over any data anymore.\n\n```js\ncursor.on('irrelevant', fn);\n```\n\n*relevant*\n\nWill fire if the cursor was irrelevant but becomes relevant again.\n\n```js\ncursor.on('relevant', fn);\n```\n\n##### N.B.\n\nFor more information concerning **Baobab**'s event emitting, see the [emmett](https://github.com/jacomyal/emmett) library.\n\n### Advanced\n\n#### Polymorphisms\n\nIf you ever need to, know that they are many ways to select and retrieve data within a *baobab*.\n\n```js\nvar tree = new Baobab({\n  palette: {\n    name: 'fancy',\n    colors: ['blue', 'yellow', 'green'],\n    currentColor: 1,\n    items: [{id: 'one', value: 'Hey'}, {id: 'two', value: 'Ho'}]\n  }\n});\n\n// Selecting\nvar colorsCursor = tree.select('palette', 'colors');\nvar colorsCursor = tree.select(['palette', 'colors']);\nvar colorsCursor = tree.select('palette').select('colors');\n\nvar paletteCursor = tree.select('palette');\n\n// Retrieving data\ncolorsCursor.get(1);\n>>> 'yellow'\n\npaletteCursor.get('colors', 2);\n>>> 'green'\n\ntree.get('palette', 'colors');\ntree.get(['palette', 'colors']);\n>>> ['blue', 'yellow', 'green']\n\n// Retrieving or selecting data by passing a function in the path\nvar complexCursor = tree.select('palette', 'colors', function(color) {\n  return color === 'green';\n});\n\ntree.get('palette', 'colors', function(color) {\n  return color === 'green';\n});\n>>> 'green'\n\n// Retrieving or selecting data by passing a descriptor object in the path\nvar complexCursor = tree.select('items', {id: 'one'}, 'value');\ntree.get('items', {id: 'one'}, 'value');\n>>> 'Hey'\n\n// Retrieving or selecting data by using the value of another cursor\nvar currentColorCursor = paletteCursor.select('colors', {$cursor: ['palette', 'currentColor']});\n\nvar currentColor = paletteCursor.get('colors', {$cursor: ['palette', 'currentColor']});\n\n// Creating a blank tree\nvar blankTree = new Baobab();\n\n// You despise \"new\"?\nvar tree = Baobab();\n```\n\n**Note**: when using a function or a descriptor object in a path, you are not filtering but rather selecting the first matching element. (It's actually the same as using something like [lodash](https://lodash.com/docs#find)'s `_.find`).\n\n#### Traversal\n\n*Going up in the tree*\n\n```js\nvar tree = new Baobab({first: {second: 'yeah'}})\n    secondCursor = tree.select('first', 'second');\n\nvar firstCursor = secondCursor.up();\n```\n\n*Going left/right/down in lists*\n\n```js\nvar tree = new Baobab({\n  list: [[1, 2], [3, 4]],\n  longList: ['one', 'two', 'three', 'four']\n});\n\nvar listCursor = tree.select('list'),\n    twoCursor = tree.select('longList', 1);\n\nlistCursor.down().right().get();\n>>> [3, 4]\n\nlistCursor.select(1).down().right().get();\n>>> 4\n\nlistCursor.select(1).down().right().left().get();\n>>> 3\n\ntwoCursor.leftmost().get();\n>>> 'one'\n\ntwoCursor.rightmost().get();\n>>> 'four'\n```\n\n*Getting root cursor*\n\n```js\nvar tree = new Baobab({first: {second: 'yeah'}}),\n    cursor = tree.select('first');\n\nvar rootCursor = tree.root;\n// or\nvar rootCursor = cursor.root();\n```\n\n*Checking information about the cursor's location in the tree*\n\n```js\ncursor.isRoot();\ncursor.isBranch();\ncursor.isLeaf();\n```\n\n#### Options\n\nYou can pass those options at instantiation.\n\n```js\nvar baobab = new Baobab(\n\n  // Initial data\n  {\n    palette: {\n      name: 'fancy',\n      colors: ['blue', 'green']\n    }\n  },\n\n  // Options\n  {\n    autoCommit: false\n  }\n)\n```\n\n* **autoCommit** *boolean* [`true`]: should the tree auto commit updates or should it let the user do so through the `commit` method?\n* **asynchronous** *boolean* [`true`]: should the tree delay the update to the next frame or fire them synchronously?\n* **facets** *object*: a collection of facets to register when the tree is istantiated. For more information, see [facets](#facets).\n* **immutable** *boolean* [`false`]: should the tree's data be immutable? Note that immutability is performed through `Object.freeze`.\n* **syncwrite** *boolean* [`false`]: when in syncwrite mode, all writes will apply to the tree synchronously, so you can easily read your writes, while keeping update events asynchronous.\n* **validate** *function*: a function in charge of validating the tree whenever it updates. See below for an example of such function.\n* **validationBehavior** *string* [`rollback`]: validation behavior of the tree. If `rollback`, the tree won't apply the current update and fire an `invalid` event while `notify` will only emit the event and let the tree enter the invalid state anyway.\n\n*Validation function*\n\n```js\nfunction validationFunction(previousState, newState, affectedPaths) {\n  // Perform validation here and return an error if\n  // the tree is invalid\n  if (!valid)\n    return new Error('Invalid tree because of reasons.');\n}\n\nvar tree = new Baobab({...}, {validate: validationFunction});\n```\n\n#### Facets\n\nFacets can be considered as a \"view\" on the data of your tree (a filtered version of an array stored within your tree, for instance).\n\nThey watch over some paths of your tree and will update their cached data only when needed. As for cursors, you can also listen to their updates.\n\nFacets can be defined at the tree's instantiation likewise:\n\n```js\nvar tree = new Baobab(\n\n  // Data\n  {\n    projects: [\n      {\n        id: 1,\n        name: 'Tezcatlipoca',\n        user: 'John'\n      },\n      {\n        id: 2,\n        name: 'Huitzilopochtli',\n        user: 'John'\n      },\n      {\n        id: 3,\n        name: 'Tlaloc',\n        user: 'Jack'\n      }\n    ],\n    currentProjectId: 1\n  },\n\n  // Options\n  {\n    facets: {\n\n      // Name of your facet\n      currentProject: {\n\n        // Cursors bound to your facet\n        // If any of the paths listed below fire\n        // an update, so will the facet.\n        cursors: {\n          id: ['currentProjectId'],\n          projects: ['projects']\n        },\n        get: function(data) {\n\n          // 'data' is the value of your mapped cursors\n\n          // Just return the wanted value\n          // Here, we use lodash to return the current's project\n          // data based on its id\n          return _.find(data.projects, {id: data.id});\n        }\n      },\n\n      // Other example\n      filteredProjects: {\n        cursors: {\n          projects: ['projects']\n        },\n        get: function(data) {\n          return data.projects.filter(function(p) {\n            return p.user === 'John';\n          });\n        }\n      },\n    }\n  }\n)\n```\n\nYou can then access facets' data and listen to their changes thusly:\n\n```js\nvar facet = tree.facets.currentProject;\n\n// Getting value (cached and only computed if needed)\nfacet.get();\n\n// Facets are also event emitters\nfacet.on('update', function() {\n  console.log('New value:', facet.get());\n});\n```\n\n#### History\n\n**Baobab** lets you record the state of any cursor so you can seamlessly implement undo/redo features.\n\n*Example*\n\n```js\n// Asynchronous tree so that examples are simpler\nvar baobab = new Baobab({colors: ['blue']}, {asynchronous: false}),\n    cursor = baobab.select('colors');\n\n// Starting to record state, with 10 records maximum\ncursor.startRecording(10);\n\ncursor.push('yellow');\ncursor.push('purple');\ncursor.push('orange');\n\ncursor.get();\n>>> ['blue', 'yellow', 'purple', 'orange']\n\ncursor.undo();\ncursor.get();\n>>> ['blue', 'yellow', 'purple']\n\ncursor.undo(2);\ncursor.get();\n>>> ['blue']\n```\n\n*Starting recording*\n\nDefault max number of records is 5.\n\n```js\ncursor.startRecording(maxNbOfRecords);\n```\n\n*Stoping recording*\n\n```js\ncursor.stopRecording();\n```\n\n*Undoing*\n\n```js\ncursor.undo();\ncursor.undo(nbOfSteps);\n```\n\n*Clearing history*\n\n```js\ncursor.clearHistory();\n```\n\n*Checking if the cursor has an history*\n\n```js\ncursor.hasHistory();\n```\n\n*Checking whether the cursor is currently recording*\n\n```js\ncursor.recording;\n```\n\n*Retrieving the cursor's history*\n\n```js\ncursor.getHistory();\n```\n\n#### Update specifications\n\nIf you ever need to specify complex updates without replacing the whole subtree you are acting on, for readability or performance reasons, you remain free to use **Baobab**'s internal update specifications.\n\nThose are widely inspired by React's immutable [helpers](http://facebook.github.io/react/docs/update.html) and can be used through `tree.update` or `cursor.update`.\n\n**Specifications**\n\nThose specifications are described by a JavaScript object that follows the nested structure you are trying to update and applying dollar-prefixed commands at leaf level.\n\nThe available commands are the following and are basically the same as the cursor's updating methods:\n\n* `$set`\n* `$apply`\n* `$chain`\n* `$push`\n* `$unshift`\n* `$splice`\n* `$merge`\n* `$unset`\n\n*Example*\n\n```js\nvar tree = new Baobab({\n  users: {\n    john: {\n      firstname: 'John',\n      lastname: 'Silver'\n    },\n    jack: {\n      firstname: 'Jack',\n      lastname: 'Gold'\n    }\n  }\n});\n\n// From tree\ntree.update({\n  users: {\n    john: {\n      firstname: {\n        $set: 'John the 3rd'\n      }\n    },\n    jack: {\n      firstname: {\n        $apply: function(firstname) {\n          return firstname + ' the 2nd';\n        }\n      }\n    }\n  }\n});\n\n// From cursor\nvar cursor = tree.select('users', 'john');\ncursor.update({\n  firstname: {\n    $set: 'Little Johnsie'\n  }\n})\n```\n\n#### Chaining mutations\n\nBecause updates will be committed later, update orders are merged when given and the new order will sometimes override older ones, especially if you set the same key twice to different values.\n\nThis is problematic when what you want is to increment a counter for instance. In those cases, you need to *chain* functions that will be assembled through composition when the update orders are merged.\n\n```js\nvar inc = function(i) {\n  return i + 1;\n};\n\n// If cursor.get() >>> 1\ncursor.apply(inc);\ncursor.apply(inc);\n// will produce 2, while\ncursor.chain(inc);\ncursor.chain(inc);\n// will produce 3\n```\n\n#### Common pitfalls\n\n**Immutable behaviour**\n\nTL;DR: Don't mutate things in your *baobab* tree. Let the tree handle its own mutations.\n\nFor performance and size reasons *baobab* does not (yet?) use an immutable data structure. However, because it aims at producing a one-way data flow for your application state (like **React** would at component level), it must be used like an immutable data structure.\n\nFor this reason, don't be surprised if you mutate things and break your tree.\n\n```js\n// This is bad:\nvar users = tree.get('users');\nusers[0].name = 'Jonathan';\n\n// This is also bad:\nvar o = {hello: 'world'};\ntree.set('key', o);\no.hello = 'other world';\n```\n\nNote that, if you want the tree to be immutable, you can now enable it through the `immutable` [option](#options).\n\n**Releasing**\n\nIn most complex use cases, you might need to release the manipulated objects, i.e. kill their event emitters and wipe their associated data.\n\nThus, any Baobab object can be cleared from memory by using the `release` method. This applies to trees, cursors and facets.\n\n```js\ntree.release();\ncursor.release();\nfacet.release();\n```\n\nNote also that releasing a tree will consequently and automatically release every of its cursors and facets.\n\n## Philosophy\n\n**UIs as pure functions**\n\nUIs should be, as far as possible, considered as pure functions. Baobab is just a way to provide the needed arguments, i.e. the data representing your app's state, to such a function.\n\nConsidering your UIs like pure functions comes along with collateral advantages like easy undo/redo features, state storing (just save your tree in the `localStorage` and here you go) and easy isomorphism.\n\n**Only data should enter the tree**\n\nYou shouldn't try to shove anything else than raw data into the tree. The tree hasn't been conceived to hold classes or fancy indexes with many circular references and cannot perform its magic on it. But, probably such magic is not desirable for those kind of abstractions anyway.\n\nThat is to say the data you insert into the tree should logically be JSON-serializable else you might be missing the point.\n\n## Migration\n\n**From v0.4.x to 1.0.0**\n\nA lot of changes occurred between `0.4.x` and `1.0.0`. Most notable changes being the following ones:\n\n* The tree now shift references by default.\n* React integration has improved and is now handled by [baobab-react](https://github.com/Yomguithereal/baobab-react).\n* `cursor.edit` and `cursor.remove` have been replaced by `cursor.set` and `cursor.unset` single argument polymorphisms.\n* A lot of options (now unnecessary) have been dropped.\n* Validation is no longer handled by [`typology`](https://github.com/jacomyal/typology) so you can choose you own validation system and so the library can remain lighter.\n* Some new features such as: `$splice`, facets and so on...\n\nFor more information, see the [changelog](./CHANGELOG.md).\n\n## Contribution\n\nContributions are obviously welcome. This project is nothing but experimental and I would cherish some feedback and advice about the library.\n\nBe sure to add unit tests if relevant and pass them all before submitting your pull request.\n\n```bash\n# Installing the dev environment\ngit clone git@github.com:Yomguithereal/baobab.git\ncd baobab\nnpm install\n\n# Running the tests\nnpm test\n\n# Linting, building\nnpm run lint\nnpm run build\n```\n\n## License\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Yomguithereal/baobab.git"
  },
  "scripts": {
    "benchmark": "node benchmark.js",
    "build": "gulp build",
    "lint": "gulp lint",
    "test": "gulp test"
  },
  "version": "1.1.2"
}
